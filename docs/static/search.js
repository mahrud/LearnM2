// Based on a script by Kathie Decora : katydecorah.com/code/lunr-and-jekyll/

// Create the lunr index for the search
var index = elasticlunr(function () {
    this.addField('title')
    this.addField('author')
    this.addField('layout')
    this.addField('content')
    this.setRef('id')
});

// Add to this index the proper metadata from the Jekyll content

index.addDoc({
    title: "FGLM",
    author: null,
    layout: "package",
    content: "\nFGLM – Compute Groebner bases via the FGLM algorithm\n\nDescription\nFGLM is a Groebner basis conversion algorithm. This means it takes a Groebner basis of an ideal with respect to one monomial order and changes it into a Groebner basis of the same ideal over a different monomial order. Conversion algorithms can be useful since sometimes when a Groebner basis over a difficult monomial order (such as lexicographic or an elimination order) is desired, it can be faster to compute a Groebner basis directly over an easier order (such as graded reverse lexicographic) and then convert rather than computing directly in the original order. Other examples of conversion algorithms include the Groebner walk and Hilbert-driven Buchberger.\n\nFGLM performs conversion by doing linear algebra in the quotient ring R/I, where I is the ideal generated by the original Groebner basis in the polynomial ring R. This requires that I is zero-dimensional.\n\nIn Macaulay2, monomial orders must be given as options to rings. For example, the following ideal has monomial order given by graded reverse lexicographic (which is also the default order in Macaulay2).\n\ni1 : R1 = QQ[x,y,z, MonomialOrder =&gt; GRevLex]\n\no1 = R1\n\no1 : PolynomialRing\n\ni2 : I1 = ideal(x*y + z - x*z, x^2 - z, 2*x^3 - x^2*y*z - 1)\n\n                            2         2        3\no2 = ideal (x*y - x*z + z, x  - z, - x y*z + 2x  - 1)\n\no2 : Ideal of R1\n\nIf we want a Groebner basis of I1 with respect to lexicographic order we could substitute the ideal into a new ring with that order and compute directly,\n\ni3 : R2 = QQ[x,y,z, MonomialOrder =&gt; Lex];\n\ni4 : I2 = sub(I1, R2);\n\no4 : Ideal of R2\n\ni5 : gens gb I2  -- performs computation in R2\n\no5 = | z6-z5-4z4-2z3+1 7y-4z5+5z4+13z3+10z2-6z-2 7x+4z5-5z4-13z3-10z2-z+2 |\n\n              1        3\no5 : Matrix R2  &lt;--- R2\n\nbut it may be faster to compute directly in the first order and then use FGLM.\n\ni6 : G1 = gb I1;  -- performs computation in R1\n\ni7 : gens fglm(G1, R2)\n\no7 = | z6-z5-4z4-2z3+1 7y-4z5+5z4+13z3+10z2-6z-2 7x+4z5-5z4-13z3-10z2-z+2 |\n\n              1        3\no7 : Matrix R2  &lt;--- R2\n\n\nReferences\n\nFurther background and details can be found in the following resources:\n\n\n  Cox, Little, O’Shea - Using Algebraic Geometry (2005)\n  Faugere, Gianni, Lazard, Mora - Efficient Computation of Zero-dimensional Groebner Bases by Change of Ordering (1993)\n  Gerdt, Yanovich - Implementation of the FGLM Algorithm and Finding Roots of Polynomial Involutive Systems (2003)\n\n\nAcknowledgement\n\nThe C++ implementation of the algorithms in Version 1.2.0 was sponsored by an IMA Coding Sprint at the Cornell University.\n\nCaveat\nThe ideal generated by the Groebner basis must be zero-dimensional.\n\nSee also\n\n\n  groebnerBasis – Gröbner basis, as a matrix\n\n\nAuthors\n\n\n  Dylan Peifer &lt;djp282@cornell.edu&gt;\n  Mahrud Sayrafi &lt;mahrud@umn.edu&gt;\n\n\nVersion\nThis documentation describes version 1.1.0 of FGLM.\n\nSource code\nThe source code from which this documentation is derived is in the file FGLM.m2.\n\nExports\n\n\n  Functions and commands\n    \n      fglm – convert a Groebner basis\n    \n  \n  Methods\n    \n      \"fglm(GroebnerBasis,Ring)\" – see fglm – convert a Groebner basis\n      \"fglm(Ideal,Ring)\" – see fglm – convert a Groebner basis\n    \n  \n\n\nFor the programmer\nThe object FGLM is a package\n.\n",
    id: 0
});
index.addDoc({
    title: "LocalRings",
    author: null,
    layout: "package",
    content: "\nLocalRings – Localizing polynomial rings at a prime ideal\n\nDescription\nThe basic definition of localization of polynomial rings at prime ideals along with various elementary operations are defined in m2/localring.m2, which in turn depends on a raw local ring type defined in e/localrings.hpp. This package extends the following methods to such local rings: syz, resolution, length, trim, mingens, minimalPresentation, symbol//, inducedMap, symbol:, saturate, annihilate.\n\nNote: Methods isSubset and symbol== are fixed in m2/modules2.m2 and reduce is fixed in m2/matrix.m2. Many other methods that only rely on the methods above, such as map, modulo, subquotient, kernel, cokernel, image, homology, Hom, Ext, Tor, etc. work for local rings automatically.\n\nIf you need specific methods that do not work, please inform Mahrud Sayrafi.\n\ni1 : R = ZZ/32003[a..d];\n\nRational quartic curve in P^3:\n\ni2 : I = monomialCurveIdeal(R,{1,3,4})\n\n                        3      2     2    2    3    2\no2 = ideal (b*c - a*d, c  - b*d , a*c  - b d, b  - a c)\n\no2 : Ideal of R\n\ni3 : C = res I\n\n      1      4      4      1\no3 = R  &lt;-- R  &lt;-- R  &lt;-- R  &lt;-- 0\n                                  \n     0      1      2      3      4\n\no3 : ChainComplex\n\ni4 : M = ideal\"a,b,c,d\"; \"maximal ideal at the origin\";\n\no4 : Ideal of R\n\ni6 : P = ideal\"a,b,c\"; \"prime ideal\";\n\no6 : Ideal of R\n\ni8 : RM = localRing(R, M);\n\ni9 : D = C ** RM;\n\ni10 : E = pruneComplex D\n\n        1       4       4       1\no10 = RM  &lt;-- RM  &lt;-- RM  &lt;-- RM\n                               \n      0       1       2       3\n\no10 : ChainComplex\n\nThat is to say, the rational quartic curve is not locally Cohen-Macaulay at the origin. Therefore the curve is not Cohen-Macaulay\n\ni11 : RP = localRing(R, P);\n\ni12 : D' = C ** RP;\n\ni13 : E' = pruneComplex D'\n\n        1       2       1\no13 = RP  &lt;-- RP  &lt;-- RP\n                       \n      0       1       2\n\no13 : ChainComplex\n\nHowever, the curve is Cohen-Macaulay at the prime ideal P (and in fact any other prime ideal)\n\nCaveat\nCurrently limited to localization at prime ideals rather than any multiplicatively closed set. Quotients of local rings are not implemented yet. Moreover, certain functions (such as symbol%, radical, minimalPrimes, leadingCoefficient) are ambiguous or not yet defined.\n\nSee also\n\n\n  PruneComplex – Pruning chain complexes over polynomial and local rings\n\n\nAuthors\n\n\n  Mahrud Sayrafi &lt;mahrud@berkeley.edu&gt;\n  Mike Stillman &lt;mike@math.cornell.edu&gt;\n  David Eisenbud &lt;de@msri.org&gt;\n\n\nVersion\nThis documentation describes version 2.0 of LocalRings.\n\nSource code\nThe source code from which this documentation is derived is in the file LocalRings.m2. The auxiliary files accompanying it are in the directory LocalRings/.\n\nExports\n\n\n  Types\n    \n      LocalRing (missing documentation)\n    \n  \n  Functions and commands\n    \n      hilbertSamuelFunction – Computes the Hilbert-Samuel Function of Modules over Local Rings\n      liftUp – Lifts various objects over R_P to R.\n      localComplement – find the splitting of the target of a map\n      localMingens – finds a minimal set of generators\n      localModulo – find the pre-image (pullback) of image of a map over a local ring\n      localPrune – find a minimal presentation\n      localResolution – find a resolution over a local ring\n      \"localRing\"\n      localsyz – find syzygies\n      setMaxIdeal – set the maximal ideal for local ring methods\n    \n  \n  Methods\n    \n      \"hilbertSamuelFunction(Ideal,Module,ZZ)\" – see hilbertSamuelFunction – Computes the Hilbert-Samuel Function of Modules over Local Rings\n      \"hilbertSamuelFunction(Ideal,Module,ZZ,ZZ)\" – see hilbertSamuelFunction – Computes the Hilbert-Samuel Function of Modules over Local Rings\n      \"hilbertSamuelFunction(Module,ZZ)\" – see hilbertSamuelFunction – Computes the Hilbert-Samuel Function of Modules over Local Rings\n      \"hilbertSamuelFunction(Module,ZZ,ZZ)\" – see hilbertSamuelFunction – Computes the Hilbert-Samuel Function of Modules over Local Rings\n      \"liftUp(Ideal,Ring)\" – see liftUp – Lifts various objects over R_P to R.\n      \"liftUp(Matrix,Ring)\" – see liftUp – Lifts various objects over R_P to R.\n      \"liftUp(Module,Ring)\" – see liftUp – Lifts various objects over R_P to R.\n      \"liftUp(MutableMatrix,Ring)\" – see liftUp – Lifts various objects over R_P to R.\n      \"liftUp(Thing)\" – see liftUp – Lifts various objects over R_P to R.\n      \"localComplement(Matrix)\" – see localComplement – find the splitting of the target of a map\n      \"localMingens(Matrix)\" – see localMingens – finds a minimal set of generators\n      \"localModulo(Matrix,Matrix)\" – see localModulo – find the pre-image (pullback) of image of a map over a local ring\n      \"localPrune(Module)\" – see localPrune – find a minimal presentation\n      \"localResolution(Ideal)\" – see localResolution – find a resolution over a local ring\n      \"localResolution(Module)\" – see localResolution – find a resolution over a local ring\n      \"localRing(Ring,Ideal)\"\n      \"localsyz(Matrix)\" – see localsyz – find syzygies\n      \"setMaxIdeal(Ideal)\" – see setMaxIdeal – set the maximal ideal for local ring methods\n    \n  \n  Symbols\n    \n      maxIdeal (missing documentation)\n      MaximalIdeal (missing documentation)\n      presentationComplex (missing documentation)\n      residueMap (missing documentation)\n    \n  \n\n\nFor the programmer\nThe object LocalRings is a package\n.\n",
    id: 1
});
index.addDoc({
    title: "PruneComplex",
    author: null,
    layout: "package",
    content: "\nPruneComplex – Pruning chain complexes over polynomial and local rings\n\nDescription\nThis package includes various methods for pruning chain complexes over polynomial and local rings. In particular, in the local or graded case the output is guaranteed to be a minimal free resolution.\n\nAlgorithms in this package are also implemented using C++ in e/mutablecomplex.hpp for speed.\n\ni1 : R = ZZ/32003[vars(0..17)];\n\ni2 : m1 = genericMatrix(R,a,3,3)\n\no2 = | a d g |\n     | b e h |\n     | c f i |\n\n             3       3\no2 : Matrix R  &lt;--- R\n\ni3 : m2 = genericMatrix(R,j,3,3)\n\no3 = | j m p |\n     | k n q |\n     | l o r |\n\n             3       3\no3 : Matrix R  &lt;--- R\n\ni4 : I = ideal(m1*m2-m2*m1)\n\no4 = ideal (d*k + g*l - b*m - c*p, b*j - a*k + e*k + h*l - b*n - c*q, c*j +\n     ------------------------------------------------------------------------\n     f*k - a*l + i*l - b*o - c*r, - d*j + a*m - e*m + d*n + g*o - f*p, - d*k\n     ------------------------------------------------------------------------\n     + b*m + h*o - f*q, - d*l + c*m + f*n - e*o + i*o - f*r, - g*j - h*m +\n     ------------------------------------------------------------------------\n     a*p - i*p + d*q + g*r, - g*k - h*n + b*p + e*q - i*q + h*r, - g*l - h*o\n     ------------------------------------------------------------------------\n     + c*p + f*q)\n\no4 : Ideal of R\n\nHere we produce an intentionally nonminimal resolution:\n\ni5 : C = res(I, FastNonminimal=&gt;true)\n\n      1      26      108      208      221      132      41      5\no5 = R  &lt;-- R   &lt;-- R    &lt;-- R    &lt;-- R    &lt;-- R    &lt;-- R   &lt;-- R  &lt;-- 0\n                                                                        \n     0      1       2        3        4        5        6       7      8\n\no5 : ChainComplex\n\nNow we prune the resolution above to get a minimal resolution:\n\ni6 : D = pruneComplex(C, UnitTest =&gt; isScalar)\n\n      1      8      33      60      61      32      5\no6 = R  &lt;-- R  &lt;-- R   &lt;-- R   &lt;-- R   &lt;-- R   &lt;-- R\n                                                    \n     0      1      2       3       4       5       6\n\no6 : ChainComplex\n\ni7 : isCommutative D.cache.pruningMap\n\no7 = true\n\ni8 : betti D == betti res I\n\no8 = true\n\n\nCaveat\nOnly supports localization at prime ideals.\n\nSee also\n\n\n  LocalRings – Localizing polynomial rings at a prime ideal\n\n\nAuthors\n\n\n  Mahrud Sayrafi &lt;mahrud@berkeley.edu&gt;\n  Mike Stillman &lt;mike@math.cornell.edu&gt;\n\n\nVersion\nThis documentation describes version 1.0 of PruneComplex.\n\nSource code\nThe source code from which this documentation is derived is in the file PruneComplex.m2. The auxiliary files accompanying it are in the directory PruneComplex/.\n\nExports\n\n\n  Functions and commands\n    \n      isScalar – check whether a ring element is a scalar\n      pruneComplex – Prunes a chain complex or list of mutable matrices\n      pruneDiff – Prunes a single differential in a chain complex or list of mutable matrices\n      pruneUnit – Prunes a unit of a differential in a list of mutable matrices\n      toChainComplex – Converts a list of mutable matrices into a ChainComplex.\n      toMutableComplex – Converts a chain complex into a list of mutable matrices.\n    \n  \n  Methods\n    \n      \"isScalar(RingElement)\" – see isScalar – check whether a ring element is a scalar\n      \"pruneComplex(ChainComplex)\" – see pruneComplex – Prunes a chain complex or list of mutable matrices\n      \"pruneComplex(ChainComplex,ZZ)\" – see pruneComplex – Prunes a chain complex or list of mutable matrices\n      \"pruneComplex(List)\" – see pruneComplex – Prunes a chain complex or list of mutable matrices\n      \"pruneComplex(List,ZZ)\" – see pruneComplex – Prunes a chain complex or list of mutable matrices\n      \"pruneDiff(ChainComplex,ZZ)\" – see pruneDiff – Prunes a single differential in a chain complex or list of mutable matrices\n      \"pruneDiff(ChainComplex,ZZ,List)\" – see pruneDiff – Prunes a single differential in a chain complex or list of mutable matrices\n      \"pruneDiff(List,ZZ)\" – see pruneDiff – Prunes a single differential in a chain complex or list of mutable matrices\n      \"pruneDiff(List,ZZ,List)\" – see pruneDiff – Prunes a single differential in a chain complex or list of mutable matrices\n      \"pruneUnit(List,ZZ,Sequence,List)\" – see pruneUnit – Prunes a unit of a differential in a list of mutable matrices\n      \"toChainComplex(List)\" – see toChainComplex – Converts a list of mutable matrices into a ChainComplex.\n      \"toChainComplex(List,Module)\" – see toChainComplex – Converts a list of mutable matrices into a ChainComplex.\n      \"toMutableComplex(ChainComplex)\" – see toMutableComplex – Converts a chain complex into a list of mutable matrices.\n    \n  \n  Symbols\n    \n      Direction – Determines the direction with which the matrices in the complex is pruned\n      PruningMap – Whether to compute a morphism of complexes\n      UnitTest – Limit which units are to be pruned\n    \n  \n\n\nFor the programmer\nThe object PruneComplex is a package\n.\n",
    id: 2
});
index.addDoc({
    title: "VirtualResolutions",
    author: null,
    layout: "package",
    content: "\nVirtualResolutions – a package for computing virtual resolutions\n\nDescription\nWhile graded minimal free resolutions are useful for studying quasicoherent sheaves over projective space, when working over a product of projective spaces or, more generally, over smooth projective toric varieties, graded minimal free resolutions over the Cox ring seem too restricted by algebraic structure that is in some sense unimportant geometrically. By allowing a limited amount of homology, virtual resolutions offer a more flexible alternative for studying toric subvarieties when compared to minimal graded free resolutions.\n\nIntroduced by Berkesch, Erman, and Smith in Virtual resolutions for a product of projective spaces (see [BES20, arXiv:1703.07631]) if $X$ is a smooth toric variety, $S$ is the Cox ring of $X$ graded by the Picard group of $X$, and $B\\subset S$ is the irrelevant ideal of $X$, then a virtual resolution of a graded $S$-module $M$ is a complex of graded free $S$-modules, which sheafifies to a resolution of the associated sheaf of $M$.\n\nThis package provides tools for constructing and studying virtual resolutions for products of projective spaces. In particular, it implements a number of the methods for constructing virtual resolutions for products of projective spaces as introduced by Berkesch, Erman, and Smith. This package also contains methods for constructing curves in $\\PP^1\\times\\PP^2$, as these are a natural source for interesting virtual resolutions.\n\nAs a running example, consider three points $([1:1],[1:4])$, $([1:2],[1:5])$, and $([1:3],[1:6])$ in $\\PP^1 \\times \\PP^1$.\n\ni1 : X = toricProjectiveSpace(1)**toricProjectiveSpace(1);\n\ni2 : S = ring X;\n\ni3 : B = ideal X;\n\no3 : Ideal of S\n\ni4 : J = saturate(intersect(\n         ideal(x_1 - x_0, x_3 - 4*x_2),\n         ideal(x_1 - 2*x_0, x_3 - 5*x_2),\n         ideal(x_1 - 3*x_0, x_3 - 6*x_2)), B);\n\no4 : Ideal of S\n\ni5 : minres = res J;\n\ni6 : multigraded betti minres\n\n        0             1               2         3\no6 = 0: 1             .               .         .\n     2: .            ab               .         .\n     3: . a3+a2b+ab2+b3               .         .\n     4: .             . 2a3b+2a2b2+2ab3         .\n     5: .             .               . a3b2+a2b3\n\no6 : MultigradedBettiTally\n\nAs described in Algorithm 3.4 of Berkesch, Erman, and Smith’s paper, one may construct a virtual resolution of a module from its graded minimal free resolution and an element of the multigraded Castelnuovo-Mumford regularity of the module. (See Maclagan and Smith’s paper Multigraded Castelnuovo-Mumford Regularity (see [MS04, arXiv:math/0305214]) for the definition of multigraded regularity.) Building on the TateOnProducts package, this package contains a function allowing one to compute the minimal elements of the multigraded Castelnuovo-Mumford regularity of a $B$-saturated module.\n\nContinuing the example from above, we see that $(2,0)$ is an element of the multigraded regularity of $S/J$. From this we can compute a virtual resolution of $S/J$.\n\ni7 : multigradedRegularity(X, J)\n\no7 = {{0, 2}, {1, 1}, {2, 0}}\n\no7 : List\n\ni8 : vres = virtualOfPair(J, {{3,1}})\n\n      1      3      2\no8 = S  &lt;-- S  &lt;-- S  &lt;-- 0\n                           \n     0      1      2      3\n\no8 : ChainComplex\n\ni9 : multigraded betti vres\n\n        0      1    2\no9 = 0: 1      .    .\n     2: .     ab    .\n     3: . a3+a2b    .\n     4: .      . 2a3b\n\no9 : MultigradedBettiTally\n\nNotice that this virtual resolution of $S/J$ is much shorter and thinner than the graded minimal free resolution of $S/J$. This is a common theme: virtual resolutions tend to be much shorter and less wide than graded minimal free resolutions over the Cox ring, but they still preserve geometric information about $S/J$.\n\nIn addition to the functions highlighted above, the VirtualResolutions package contains a number of other tools for constructing and studying virtual resolutions. In particular, there are functions to construct virtual resolutions for zero dimensionsal subschemes, to check whether a complex is a virtual resolution, and to construct curves in $\\PP^1\\times\\PP^2$.\n\nContributors\nThe following people have generously contributed code or worked on this package.\n\n\n  Daniel Erman\n  Gregory G. Smith\n  Lauren Cranton Heller\n\n\nReferences\n\n\n  \n  \n\n\nAuthors\n\n\n  Ayah Almousa &lt;aka66@cornell.edu&gt;\n  Christine Berkesch &lt;cberkesc@umn.edu&gt;\n  Juliette Bruce &lt;jebruce2@wisc.edu&gt;\n  David Eisenbud &lt;de@msri.org&gt;\n  Michael Loper &lt;loper012@umn.edu&gt;\n  Mahrud Sayrafi &lt;mahrud@umn.edu&gt;\n\n\nCertification \nVersion 1.2 of this package was accepted for publication in volume 10 of The Journal of Software for Algebra and Geometry on 19 May 2020, in the article The virtual resolutions package for Macaulay2. That version can be obtained from the journal or from the Macaulay2 source code repository\n.\n\nVersion\nThis documentation describes version 1.3 of VirtualResolutions.\n\nSource code\nThe source code from which this documentation is derived is in the file VirtualResolutions.m2. The auxiliary files accompanying it are in the directory VirtualResolutions/.\n\nExports\n\n\n  Functions and commands\n    \n      curveFromP3toP1P2 – creates the ideal of a curve in P^1xP^2 from the ideal of a curve in P^3\n      idealSheafGens – creates a list of subsets of the minimal generators that generate a given ideal up to saturation\n      isVirtual – checks whether a chain complex is a virtual resolution\n      multigradedRegularity – computes the minimal elements of the multigraded regularity of a module over a multigraded ring\n      randomCurveP1P2 – creates the ideal of a random curve in P^1xP^2\n      randomMonomialCurve – creates the ideal of a random monomial curve of degree (d,e) in P^1xP^2\n      randomRationalCurve – creates the ideal of a random rational curve of degree (d,e) in P^1xP^2\n      resolveViaFatPoint – returns a virtual resolution of a zero-dimensional scheme\n      virtualOfPair – creates a virtual resolution from a free resolution by keeping only summands of specified degrees\n    \n  \n  Methods\n    \n      \"curveFromP3toP1P2(Ideal)\" – see curveFromP3toP1P2 – creates the ideal of a curve in P^1xP^2 from the ideal of a curve in P^3\n      \"idealSheafGens(ZZ,Ideal,Ideal)\" – see idealSheafGens – creates a list of subsets of the minimal generators that generate a given ideal up to saturation\n      \"idealSheafGens(ZZ,Ideal,NormalToricVariety)\" – see idealSheafGens – creates a list of subsets of the minimal generators that generate a given ideal up to saturation\n      \"isVirtual(Ideal,ChainComplex)\" – see isVirtual – checks whether a chain complex is a virtual resolution\n      \"isVirtual(NormalToricVariety,ChainComplex)\" – see isVirtual – checks whether a chain complex is a virtual resolution\n      \"multigradedRegularity(NormalToricVariety,Ideal)\" – see multigradedRegularity – computes the minimal elements of the multigraded regularity of a module over a multigraded ring\n      \"multigradedRegularity(NormalToricVariety,Module)\" – see multigradedRegularity – computes the minimal elements of the multigraded regularity of a module over a multigraded ring\n      \"multigradedRegularity(Ring,Ideal)\" – see multigradedRegularity – computes the minimal elements of the multigraded regularity of a module over a multigraded ring\n      \"multigradedRegularity(Ring,Module)\" – see multigradedRegularity – computes the minimal elements of the multigraded regularity of a module over a multigraded ring\n      \"randomCurveP1P2(ZZ,ZZ)\" – see randomCurveP1P2 – creates the ideal of a random curve in P^1xP^2\n      \"randomCurveP1P2(ZZ,ZZ,Ring)\" – see randomCurveP1P2 – creates the ideal of a random curve in P^1xP^2\n      \"randomMonomialCurve(ZZ,ZZ)\" – see randomMonomialCurve – creates the ideal of a random monomial curve of degree (d,e) in P^1xP^2\n      \"randomMonomialCurve(ZZ,ZZ,Ring)\" – see randomMonomialCurve – creates the ideal of a random monomial curve of degree (d,e) in P^1xP^2\n      \"randomRationalCurve(ZZ,ZZ)\" – see randomRationalCurve – creates the ideal of a random rational curve of degree (d,e) in P^1xP^2\n      \"randomRationalCurve(ZZ,ZZ,Ring)\" – see randomRationalCurve – creates the ideal of a random rational curve of degree (d,e) in P^1xP^2\n      \"resolveViaFatPoint(Ideal,Ideal,List)\" – see resolveViaFatPoint – returns a virtual resolution of a zero-dimensional scheme\n      \"virtualOfPair(ChainComplex,List)\" – see virtualOfPair – creates a virtual resolution from a free resolution by keeping only summands of specified degrees\n      \"virtualOfPair(Ideal,List)\" – see virtualOfPair – creates a virtual resolution from a free resolution by keeping only summands of specified degrees\n      \"virtualOfPair(Module,List)\" – see virtualOfPair – creates a virtual resolution from a free resolution by keeping only summands of specified degrees\n    \n  \n  Symbols\n    \n      Attempt – limit number of attempts for randomCurveP1P2\n      GeneralElements – combines generators of same degree into a general linear combination\n      \"LowerLimit\" – see multigradedRegularity – computes the minimal elements of the multigraded regularity of a module over a multigraded ring\n      \"UpperLimit\" – see multigradedRegularity – computes the minimal elements of the multigraded regularity of a module over a multigraded ring\n      PreserveDegree – Determines if curve is disjoint from base loci\n    \n  \n\n\nFor the programmer\nThe object VirtualResolutions is a package\n.\n",
    id: 3
});
index.addDoc({
    title: "The Twisted Cubic",
    author: "Mahrud Sayrafi",
    layout: "doc",
    content: "Let’s first define the coordinate ring of ( \\P^3 ), where the twisted cubic lies:\n\n\n  i1 : kk = ZZ/32003;\n  i2 : R = kk[x,y,z,w]; -- this is a ring\n\n\nParametric Curve\n\nThis methods yields the twisted cubic as the ideal of a projective curve given parametrically by the map:\n\\[\n\\begin{aligned}\nk[x,y,z] &amp;\\to k[t] \\cr\nx &amp;\\mapsto t^3 \\cr\ny &amp;\\mapsto t^2 \\cr\nz &amp;\\mapsto t.\n \\end{aligned}\n \\]\n\n\n  i3 : monomialCurveIdeal(R, {1,2,3})\n\n             2                    2\no3 = ideal (z  - y*w, y*z - x*w, y  - x*z)\n\no3 : Ideal of R\n\n\nDeterminantal Ideal\n\nThis method defines the twisted cubic as a determinantal ideal of $2\\times 2$ minors, that is:\n\\[\nI = I_2 \\begin{pmatrix}\nx &amp; y &amp; z \\cr\ny &amp; z &amp; w\n\\end{pmatrix}\\]\n\n\n  i4 : minors(2, matrix {{R_0, R_1, R_2},{R_1,R_2,R_3}})\n\n               2                        2\no4 = ideal (- y  + x*z, - y*z + x*w, - z  + y*w)\n\no4 : Ideal of R\n\n\nVeronese Embedding\n\nThis method defines the twisted cubic as the kernel of the Veronese embedding of degree three on the projective line.\nThat is:\n\n\n  i5 : kernel map(kk[s,t], R, {s^3, s^2*t, s*t^2, t^3})\n\n             2                    2\no5 = ideal (z  - y*w, y*z - x*w, y  - x*z)\n\no5 : Ideal of R\n\n\nResolution\n\n$$\n0 \\to 2\\mathcal O_{\\\\P^3}(-3) \\to 3\\mathcal O_{\\\\P^3}(-2) \\to \\mathcal O_{\\\\P^3} \\to \\mathcal O_C \\to 0\n$$\n",
    id: 4
});
console.log( jQuery.type(index) );

// Builds reference data (maybe not necessary for us, to check)
var store = [{
    "title": "FGLM",
    "author": null,
    "layout": "package",
    "link": "/packages/FGLM/",
}
	     ,{
    "title": "LocalRings",
    "author": null,
    "layout": "package",
    "link": "/packages/LocalRings/",
}
	     ,{
    "title": "PruneComplex",
    "author": null,
    "layout": "package",
    "link": "/packages/PruneComplex/",
}
	     ,{
    "title": "VirtualResolutions",
    "author": null,
    "layout": "package",
    "link": "/packages/VirtualResolutions/",
}
	     ,{
    "title": "The Twisted Cubic",
    "author": "Mahrud Sayrafi",
    "layout": "doc",
    "link": "/docs/example/",
}
	     ]

// Query
var searchDiv = $("input#x-search-query");
var resultDiv = $("#results");
var searchParams = new URLSearchParams(window.location.search)
if (searchParams.has('q')) {
    searchDiv.value = searchParams.get('q');
}

function doSearch() {
    var query = searchDiv.val();
    if (query.length <= 3) {
	resultDiv.empty();
	return;
    }

    // The search is then launched on the index built with Lunr
    var result = index.search(query);
    resultDiv.empty();
    if (result.length == 0) {
	resultDiv.append('<p class="">No results found.</p>');
    } else if (result.length == 1) {
	resultDiv.append('<p class="">Found '+result.length+' result</p>');
    } else {
	resultDiv.append('<p class="">Found '+result.length+' results</p>');
    }
    // Loop through, match, and add results
    for (var item in result) {
	var ref = result[item].ref;
	var searchitem = '<div class="result"><p><a href="/LearnM2'+store[ref].link+'?q='+query+'">'+store[ref].title+'</a></p></div>';
	resultDiv.append(searchitem);
    }

    var regex = new RegExp("<mark>(.*)</mark>", "gim");
    var content = document.getElementById("main").innerHTML;
    document.getElementById("main").innerHTML = content.replace(regex, "$1");
    doHighlight();
}

// Highlight search Query
function doHighlight() {
    var query = searchDiv.val();
    // regex matches at beginning of line, end of line or word boundary
    var regex = new RegExp("(?:^|\\b)(.{0,5})(" + query + ")(.{0,5})(?:$|\\b)", "gim");
    var content = document.getElementById("main").innerHTML;
    document.getElementById("main").innerHTML = content.replace(regex, "$1<mark>$2</mark>$3");
}

$(document).ready(function() {
    if (searchParams.has('q')) {
	searchDiv.val(searchParams.get('q'));
	doSearch();
    }
    searchDiv.on('keyup', doSearch);
});
