// Based on a script by Kathie Decora : katydecorah.com/code/lunr-and-jekyll/

// Create the lunr index for the search
var index = elasticlunr(function () {
    this.addField('title')
    this.addField('author')
    this.addField('layout')
    this.addField('content')
    this.setRef('id')
});

// Add to this index the proper metadata from the Jekyll content

index.addDoc({
    title: "FGLM",
    author: null,
    layout: "package",
    content: "fglm – convert a Groebner basis\n\nSynopsis\n\n\n  \n    \n      Usage:\n      H = fglm(G, R)\n      H = fglm(I, R)\n    \n  \n  Inputs:\n    \n      G, a Groebner basis\n, the starting Groebner basis\n      I, an ideal\n, the starting ideal\n      R, a ring\n, a ring with the target monomial order\n    \n  \n  Outputs:\n    \n      H, a Groebner basis\n, the new Groebner basis in the target monomial order\n    \n  \n\n\nDescription\nFGLM takes a Groebner basis of an ideal with respect to one monomial order and changes it into a Groebner basis of the same ideal over a different monomial order. The initial order is given by the ring of G and the target order is the order in R. When given an ideal I as input a Groebner basis of I in the ring of I is initially computed directly, and then this Groebner basis is converted into a Groebner basis in the ring R.\n\ni1 : R1 = QQ[x,y,z];\n\ni2 : I1 = ideal(x^2 + 2*y^2 - y - 2*z, x^2 - 8*y^2 + 10*z - 1, x^2 - 7*y*z);\n\no2 : Ideal of R1\n\ni3 : R2 = QQ[x,y,z, MonomialOrder =&gt; Lex];\n\ni4 : fglm(I1, R2)\n\no4 = GroebnerBasis[status: done; S-pairs encountered up to degree 0]\n\no4 : GroebnerBasis\n\n\nCaveat\nThe ideal I generated by G must be zero-dimensional. The target ring R must be the same ring as the ring of G or I, except with different monomial order. R must be a polynomial ring over a field.\n\nSee also\n\n\n  FGLM – Compute Groebner bases via the FGLM algorithm\n  groebnerBasis – Gröbner basis, as a matrix\n\n\nWays to use fglm :\n\n\n  fglm(GroebnerBasis,Ring)\n  fglm(Ideal,Ring)\n\n",
    id: 0
});
index.addDoc({
    title: "PruneComplex",
    author: null,
    layout: "default",
    content: "PruneComplex – Pruning chain complexes over polynomial and local rings\n\nDescription\nThis package includes various methods for pruning chain complexes over polynomial and local rings. In particular, in the local or graded case the output is guaranteed to be a minimal free resolution.\n\nAlgorithms in this package are also implemented using C++ in e/mutablecomplex.hpp for speed.\n\ni1 : R = ZZ/32003[vars(0..17)];\ni2 : m1 = genericMatrix(R,a,3,3)\n\no2 = | a d g |\n     | b e h |\n     | c f i |\n\n             3       3\no2 : Matrix R  &lt;--- R\ni3 : m2 = genericMatrix(R,j,3,3)\n\no3 = | j m p |\n     | k n q |\n     | l o r |\n\n             3       3\no3 : Matrix R  &lt;--- R\ni4 : I = ideal(m1*m2-m2*m1)\n\no4 = ideal (d*k + g*l - b*m - c*p, b*j - a*k + e*k + h*l - b*n - c*q, c*j +\n     ------------------------------------------------------------------------\n     f*k - a*l + i*l - b*o - c*r, - d*j + a*m - e*m + d*n + g*o - f*p, - d*k\n     ------------------------------------------------------------------------\n     + b*m + h*o - f*q, - d*l + c*m + f*n - e*o + i*o - f*r, - g*j - h*m +\n     ------------------------------------------------------------------------\n     a*p - i*p + d*q + g*r, - g*k - h*n + b*p + e*q - i*q + h*r, - g*l - h*o\n     ------------------------------------------------------------------------\n     + c*p + f*q)\n\no4 : Ideal of R\n\n\nHere we produce an intentionally nonminimal resolution:\n\ni5 : C = res(I, FastNonminimal=&gt;true)\n\n      1      26      108      208      221      132      41      5\no5 = R  &lt;-- R   &lt;-- R    &lt;-- R    &lt;-- R    &lt;-- R    &lt;-- R   &lt;-- R  &lt;-- 0\n                                                                        \n     0      1       2        3        4        5        6       7      8\n\no5 : ChainComplex\n\n\nNow we prune the resolution above to get a minimal resolution:\n\ni6 : D = pruneComplex(C, UnitTest =&gt; isScalar)\n\n      1      8      33      60      61      32      5\no6 = R  &lt;-- R  &lt;-- R   &lt;-- R   &lt;-- R   &lt;-- R   &lt;-- R\n                                                    \n     0      1      2       3       4       5       6\n\no6 : ChainComplex\ni7 : isCommutative D.cache.pruningMap\n\no7 = true\ni8 : betti D == betti res I\n\no8 = true\n\n\n\nCaveat\nOnly supports localization at prime ideals.\n\nSee also\n\n\n  LocalRings – Localizing polynomial rings at a prime ideal\n\n\nAuthors\n\n\n  Mahrud Sayrafi mahrud@berkeley.edumahrud@berkeley.edu\n  Mike Stillman mike@math.cornell.edumike@math.cornell.edu\n\n\nVersion\nThis documentation describes version 1.0 of PruneComplex.\nSource code\nThe source code from which this documentation is derived is in the file PruneComplex.m2.  The auxiliary files accompanying it are in the directory PruneComplex/.\nExports\n\n\n  Functions and commands\n    \n      isScalar – check whether a ring element is a scalar\n      pruneComplex – Prunes a chain complex or list of mutable matrices\n      pruneDiff – Prunes a single differential in a chain complex or list of mutable matrices\n      pruneUnit – Prunes a unit of a differential in a list of mutable matrices\n      toChainComplex – Converts a list of mutable matrices into a ChainComplex.\n      toMutableComplex – Converts a chain complex into a list of mutable matrices.\n    \n  \n  Symbols\n    \n      Direction – Determines the direction with which the matrices in the complex is pruned\n      PruningMap – Whether to compute a morphism of complexes\n      UnitTest – Limit which units are to be pruned\n    \n  \n\n",
    id: 1
});
index.addDoc({
    title: "The Twisted Cubic",
    author: "Mahrud Sayrafi",
    layout: "doc",
    content: "Let’s first define the coordinate ring of ( \\P^3 ), where the twisted cubic lies:\n\n\n  i1 : kk = ZZ/32003;\n  i2 : R = kk[x,y,z,w]; -- this is a ring\n\n\nmonomialCurveIdeal\n\nThis methods yields the twisted cubic as the ideal of a projective curve given parametrically by the map:\n\\[\n\\begin{aligned}\nk[x,y,z] &amp;\\to k[t] \\cr\nx &amp;\\mapsto t^3 \\cr\ny &amp;\\mapsto t^2 \\cr\nz &amp;\\mapsto t.\n \\end{aligned}\n \\]\n\n\n  i3 : monomialCurveIdeal(R, {1,2,3})\n\n             2                    2\no3 = ideal (z  - y*w, y*z - x*w, y  - x*z)\n\no3 : Ideal of R\n\n\nDeterminantal Ideal\n\nThis method defines the twisted cubic as a determinantal ideal of $2\\times 2$ minors, that is:\n\\[\nI = I_2 \\begin{pmatrix}\nx &amp; y &amp; z \\cr\ny &amp; z &amp; w\n\\end{pmatrix}\\]\n\n\n  i4 : minors(2, matrix {{R_0, R_1, R_2},{R_1,R_2,R_3}})\n\n               2                        2\no4 = ideal (- y  + x*z, - y*z + x*w, - z  + y*w)\n\no4 : Ideal of R\n\n\nVeronese Embedding\n\nThis method defines the twisted cubic as the kernel of the Veronese embedding of degree three on the projective line.\nThat is:\n\n\n  i5 : kernel map(kk[s,t], R, {s^3, s^2*t, s*t^2, t^3})\n\n             2                    2\no5 = ideal (z  - y*w, y*z - x*w, y  - x*z)\n\no5 : Ideal of R\n\n\nResolution\n\n$$\n0 \\to 2\\mathcal O_{\\\\P^3}(-3) \\to 3\\mathcal O_{\\\\P^3}(-2) \\to \\mathcal O_{\\\\P^3} \\to \\mathcal O_C \\to 0\n$$\n",
    id: 2
});
console.log( jQuery.type(index) );

// Builds reference data (maybe not necessary for us, to check)
var store = [{
    "title": "FGLM",
    "author": null,
    "layout": "package",
    "link": "/packages/FGLM/",
}
	     ,{
    "title": "PruneComplex",
    "author": null,
    "layout": "default",
    "link": "/packages/PruneComplex/",
}
	     ,{
    "title": "The Twisted Cubic",
    "author": "Mahrud Sayrafi",
    "layout": "doc",
    "link": "/docs/example/",
}
	     ]

// Query
var searchDiv = $("input#x-search-query");
var resultDiv = $("#results");
var searchParams = new URLSearchParams(window.location.search)
if (searchParams.has('q')) {
    searchDiv.value = searchParams.get('q');
}

function doSearch() {
    var query = searchDiv.val();
    if (query.length <= 3) {
	resultDiv.empty();
	return;
    }

    // The search is then launched on the index built with Lunr
    var result = index.search(query);
    resultDiv.empty();
    if (result.length == 0) {
	resultDiv.append('<p class="">No results found.</p>');
    } else if (result.length == 1) {
	resultDiv.append('<p class="">Found '+result.length+' result</p>');
    } else {
	resultDiv.append('<p class="">Found '+result.length+' results</p>');
    }
    // Loop through, match, and add results
    for (var item in result) {
	var ref = result[item].ref;
	var searchitem = '<div class="result"><p><a href="/m2doc'+store[ref].link+'?q='+query+'">'+store[ref].title+'</a></p></div>';
	resultDiv.append(searchitem);
    }

    var regex = new RegExp("<mark>(.*)</mark>", "gim");
    var content = document.getElementById("main").innerHTML;
    document.getElementById("main").innerHTML = content.replace(regex, "$1");
    doHighlight();
}

// Highlight search Query
function doHighlight() {
    var query = searchDiv.val();
    // regex matches at beginning of line, end of line or word boundary
    var regex = new RegExp("(?:^|\\b)(.{0,5})(" + query + ")(.{0,5})(?:$|\\b)", "gim");
    var content = document.getElementById("main").innerHTML;
    document.getElementById("main").innerHTML = content.replace(regex, "$1<mark>$2</mark>$3");
}

$(document).ready(function() {
    if (searchParams.has('q')) {
	searchDiv.val(searchParams.get('q'));
	doSearch();
    }
    searchDiv.on('keyup', doSearch);
});
